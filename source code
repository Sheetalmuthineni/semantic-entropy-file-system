import streamlit as st
import os
import shutil
import sqlite3
import hashlib
import fitz
import re
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.cluster import KMeans

# ================= CONFIG =================
ROOT_FOLDER = "SEFS_ROOT"
LOG_FILE = "sefs_log.txt"
MIN_WORDS = 5

os.makedirs(ROOT_FOLDER, exist_ok=True)

# ================= DATABASE =================
conn = sqlite3.connect("users.db", check_same_thread=False)
c = conn.cursor()
c.execute("CREATE TABLE IF NOT EXISTS users(username TEXT, password TEXT)")
conn.commit()

def hash_password(password):
    return hashlib.sha256(password.encode()).hexdigest()

def register(username, password):
    c.execute("INSERT INTO users VALUES (?,?)",
              (username, hash_password(password)))
    conn.commit()

def login(username, password):
    c.execute("SELECT * FROM users WHERE username=? AND password=?",
              (username, hash_password(password)))
    return c.fetchone()

# ================= FILE UTILITIES =================
def extract_text_from_pdf(path):
    text = ""
    with fitz.open(path) as doc:
        for page in doc:
            text += page.get_text()
    return text

def clean_text(text):
    text = re.sub(r'\s+', ' ', text)
    text = re.sub(r'[^A-Za-z0-9 ]+', '', text)
    return text.strip()

def get_all_files(root):
    all_files = []
    for root_dir, dirs, files in os.walk(root):
        for file in files:
            if file.endswith(".txt") or file.endswith(".pdf"):
                all_files.append(os.path.join(root_dir, file))
    return all_files

# ================= SEMANTIC GROUPING =================
def semantic_grouping():

    files = get_all_files(ROOT_FOLDER)

    texts = []
    valid_files = []

    for f in files:
        try:
            if f.endswith(".txt"):
                with open(f, "r", encoding="utf-8") as file:
                    text = file.read()
            else:
                text = extract_text_from_pdf(f)

            text = clean_text(text)

            if len(text.split()) >= MIN_WORDS:
                texts.append(text)
                valid_files.append(f)

        except:
            continue

    if len(texts) < 2:
        st.warning("Need at least 2 meaningful files to organize.")
        return

    # Convert text to numerical vectors
    vectorizer = TfidfVectorizer(stop_words='english')
    X = vectorizer.fit_transform(texts)

    # Decide number of clusters
    n_clusters = max(2, min(5, len(texts)//2))

    kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
    labels = kmeans.fit_predict(X)

    # Remove empty folders
    for folder in os.listdir(ROOT_FOLDER):
        folder_path = os.path.join(ROOT_FOLDER, folder)
        if os.path.isdir(folder_path) and not os.listdir(folder_path):
            os.rmdir(folder_path)

    # Create folders and move files
    for cluster_id in range(n_clusters):

        cluster_indices = [i for i, label in enumerate(labels) if label == cluster_id]
        if not cluster_indices:
            continue

        # Generate folder name using top keywords
        center = kmeans.cluster_centers_[cluster_id]
        feature_names = vectorizer.get_feature_names_out()
        top_indices = center.argsort()[-3:][::-1]
        keywords = "_".join([feature_names[i] for i in top_indices])

        folder_name = keywords if keywords else f"Group_{cluster_id}"
        folder_path = os.path.join(ROOT_FOLDER, folder_name)
        os.makedirs(folder_path, exist_ok=True)

        for index in cluster_indices:
            old_path = valid_files[index]
            new_path = os.path.join(folder_path, os.path.basename(old_path))

            if os.path.dirname(old_path) != folder_path:
                shutil.move(old_path, new_path)

                # UTF-8 safe logging (Windows fix)
                with open(LOG_FILE, "a", encoding="utf-8") as log:
                    log.write(f"Moved {old_path} to {folder_name}\n")

# ================= UI =================
st.set_page_config(page_title="Smart File Organizer", layout="wide")

st.title("ðŸ“‚ Smart File Organizer")
st.caption("Upload â†’ Analyze â†’ Automatically Organize by Content")

if "logged_in" not in st.session_state:
    st.session_state.logged_in = False

# ================= LOGIN / REGISTER =================
if not st.session_state.logged_in:

    menu = st.sidebar.selectbox("Navigation", ["Login", "Register"])

    if menu == "Register":
        st.subheader("Create Account")
        username = st.text_input("Username")
        password = st.text_input("Password", type="password")

        if st.button("Register"):
            if username and password:
                register(username, password)
                st.success("Account created successfully!")
            else:
                st.error("Enter valid details")

    if menu == "Login":
        st.subheader("Login")
        username = st.text_input("Username")
        password = st.text_input("Password", type="password")

        if st.button("Login"):
            if login(username, password):
                st.session_state.logged_in = True
                st.rerun()
            else:
                st.error("Invalid credentials")

# ================= MAIN SYSTEM =================
else:

    st.sidebar.success("Logged In")

    if st.sidebar.button("Logout"):
        st.session_state.logged_in = False
        st.rerun()

    # Upload section
    st.sidebar.header("Upload File")
    uploaded = st.sidebar.file_uploader("Upload TXT or PDF",
                                        type=["txt", "pdf"])

    if uploaded:
        save_path = os.path.join(ROOT_FOLDER, uploaded.name)
        with open(save_path, "wb") as f:
            f.write(uploaded.getbuffer())
        st.sidebar.success("File uploaded successfully!")

    # Organize button
    if st.button("ðŸ”„ Analyze & Organize Files"):
        semantic_grouping()
        st.success("Files organized successfully!")

    # File preview section
    st.subheader("ðŸ“„ File Preview")

    all_files = get_all_files(ROOT_FOLDER)

    if all_files:
        selected = st.selectbox("Select File",
                                [os.path.basename(f) for f in all_files])

        file_path = next(f for f in all_files
                         if os.path.basename(f) == selected)

        if file_path.endswith(".txt"):
            with open(file_path, "r", encoding="utf-8") as f:
                st.text_area("Content", f.read(), height=300)
        else:
            text = extract_text_from_pdf(file_path)
            st.text_area("PDF Content", text[:2000], height=300)

        if st.button("ðŸ—‘ Delete File"):
            os.remove(file_path)
            st.success("File deleted!")
            st.rerun()

    # Activity Log
    st.subheader("ðŸ“œ Activity Log")

    if os.path.exists(LOG_FILE):
        with open(LOG_FILE, "r", encoding="utf-8") as log:
            st.text(log.read())
